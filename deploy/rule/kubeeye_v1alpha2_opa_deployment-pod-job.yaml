apiVersion: kubeeye.kubesphere.io/v1alpha2
kind: InspectRule
metadata:
  creationTimestamp: null
  labels:
    app.kubernetes.io/created-by: kubeeye
    app.kubernetes.io/instance: inspectrules-sample
    app.kubernetes.io/managed-by: kustomize
    app.kubernetes.io/name: inspectrules
    app.kubernetes.io/part-of: kubeeye
    kubeeye.kubesphere.io/rule-group: kubeeye_workloads_rego
  name: inspect-rule-opa-deployment-job-pod
  namespace: kubeeye-system
spec:
  opas:
  - module: kubeeye_workloads_rego
    name: runAsNonRootRule
    rule: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "warning"

          PodSetrunAsNonRoot(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NotRunAsNonRoot"
          }
      }

      PodSetrunAsNonRoot(resource) {
          not resource.Object.spec.securityContext.runAsNonRoot
          containers := resource.Object.spec.containers[_]
          not containers.securityContext.runAsNonRoot
      }
      PodSetrunAsNonRoot(resource) {
          resource.Object.spec.securityContext.runAsNonRoot == false
          containers := resource.Object.spec.containers[_]
          not containers.securityContext.runAsNonRoot
      }
      PodSetrunAsNonRoot(resource) {
          not resource.Object.spec.securityContext.runAsNonRoot
          containers := resource.Object.spec.containers[_]
          containers.securityContext.runAsNonRoot == false
      }
      PodSetrunAsNonRoot(resource) {
          resource.Object.spec.securityContext.runAsNonRoot = false
          containers := resource.Object.spec.containers[_]
          containers.securityContext.runAsNonRoot == false
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "warning"

          workloadsSetrunAsNonRoot(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NotRunAsNonRoot"
          }
      }

      workloadsSetrunAsNonRoot(resource) {
          not resource.Object.spec.securityContext.runAsNonRoot
          containers := resource.Object.spec.template.spec.containers[_]
          not containers.securityContext.runAsNonRoot
      }
      workloadsSetrunAsNonRoot(resource) {
          resource.Object.spec.securityContext.runAsNonRoot == false
          containers := resource.Object.spec.template.spec.containers[_]
          not containers.securityContext.runAsNonRoot
      }
      workloadsSetrunAsNonRoot(resource) {
          not resource.Object.spec.securityContext.runAsNonRoot
          containers := resource.Object.spec.template.spec.containers[_]
          containers.securityContext.runAsNonRoot == false
      }
      workloadsSetrunAsNonRoot(resource) {
          resource.Object.spec.securityContext.runAsNonRoot = false
          containers := resource.Object.spec.template.spec.containers[_]
          containers.securityContext.runAsNonRoot == false
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "warning"

          CronJobSetrunAsNonRoot(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NotRunAsNonRoot"
          }
      }

      CronJobSetrunAsNonRoot(resource) {
          not resource.Object.spec.securityContext.runAsNonRoot
          containers := resource.spec.jobTemplate.spec.template.spec.containers[_]
          not containers.securityContext.runAsNonRoot
      }
      CronJobSetrunAsNonRoot(resource) {
          resource.Object.spec.securityContext.runAsNonRoot == false
          containers := resource.spec.jobTemplate.spec.template.spec.containers[_]
          not containers.securityContext.runAsNonRoot
      }
      CronJobSetrunAsNonRoot(resource) {
          not resource.Object.spec.securityContext.runAsNonRoot
          containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
          containers.securityContext.runAsNonRoot == false
      }
      CronJobSetrunAsNonRoot(resource) {
          resource.Object.spec.securityContext.runAsNonRoot = false
          containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
          containers.securityContext.runAsNonRoot == false
      }
  - module: kubeeye_workloads_rego
    name: readinessProbeRule
    rule: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "warning"

          PodSetreadinessProbe(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoReadinessProbe"
          }
      }

      PodSetreadinessProbe(resource) {
          containers := resource.Object.spec.containers[_]
          not containers.readinessProbe
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "warning"

          workloadsSetreadinessProbe(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoReadinessProbe"
          }
      }

      workloadsSetreadinessProbe(resource) {
          containers := resource.Object.spec.template.spec.containers[_]
          not containers.readinessProbe
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "warning"

          CronjobSetreadinessProbe(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoReadinessProbe"
          }
      }

      CronjobSetreadinessProbe(resource) {
          containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
          not containers.readinessProbe
      }
  - module: kubeeye_workloads_rego
    name: readOnlyRootFilesystemRule
    rule: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "warning"

          PodSetreadOnlyRootFilesystem(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NotReadOnlyRootFilesystem"
          }
      }

      PodSetreadOnlyRootFilesystem(resource) {
          not resource.Object.spec.securityContext.readOnlyRootFilesystem == true
          containers := resource.Object.spec.containers[_]
          not containers.securityContext.readOnlyRootFilesystem == true
      }
      PodSetreadOnlyRootFilesystem(resource) {
          not resource.Object.spec.securityContext.readOnlyRootFilesystem
          containers := resource.Object.spec.containers[_]
          not containers.securityContext.readOnlyRootFilesystem == true
      }
      PodSetreadOnlyRootFilesystem(resource) {
          not resource.Object.spec.securityContext.readOnlyRootFilesystem == true
          containers := resource.Object.spec.containers[_]
          not containers.securityContext.readOnlyRootFilesystem
      }
      PodSetreadOnlyRootFilesystem(resource) {
          not resource.Object.spec.securityContext.readOnlyRootFilesystem
          containers := resource.Object.spec.containers[_]
          not containers.securityContext.readOnlyRootFilesystem
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "warning"

          workloadsSetreadOnlyRootFilesystem(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NotReadOnlyRootFilesystem"
          }
      }

      workloadsSetreadOnlyRootFilesystem(resource) {
          not resource.Object.spec.securityContext.readOnlyRootFilesystem == true
          containers := resource.Object.spec.template.spec.containers[_]
          not containers.securityContext.readOnlyRootFilesystem == true
      }
      workloadsSetreadOnlyRootFilesystem(resource) {
          not resource.Object.spec.securityContext.readOnlyRootFilesystem
          containers := resource.Object.spec.template.spec.containers[_]
          not containers.securityContext.readOnlyRootFilesystem == true
      }
      workloadsSetreadOnlyRootFilesystem(resource) {
          not resource.Object.spec.securityContext.readOnlyRootFilesystem == true
          containers := resource.Object.spec.template.spec.containers[_]
          not containers.securityContext.readOnlyRootFilesystem
      }
      workloadsSetreadOnlyRootFilesystem(resource) {
          not resource.Object.spec.securityContext.readOnlyRootFilesystem
          containers := resource.Object.spec.template.spec.containers[_]
          not containers.securityContext.readOnlyRootFilesystem
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "warning"

          CronJobSetreadOnlyRootFilesystem(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NotReadOnlyRootFilesystem"
          }
      }

      CronJobSetreadOnlyRootFilesystem(resource) {
          not resource.Object.spec.securityContext.readOnlyRootFilesystem == true
          containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
          not containers.securityContext.readOnlyRootFilesystem == true
      }
      CronJobSetreadOnlyRootFilesystem(resource) {
          not resource.Object.spec.securityContext.readOnlyRootFilesystem
          containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
          not containers.securityContext.readOnlyRootFilesystem == true
      }
      CronJobSetreadOnlyRootFilesystem(resource) {
          not resource.Object.spec.securityContext.readOnlyRootFilesystem == true
          containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
          not containers.securityContext.readOnlyRootFilesystem
      }
      CronJobSetreadOnlyRootFilesystem(resource) {
          not resource.Object.spec.securityContext.readOnlyRootFilesystem
          containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
          not containers.securityContext.readOnlyRootFilesystem
      }
  - module: kubeeye_workloads_rego
    name: privilegedRule
    rule: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "danger"

          PodSetPrivilegedRule(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "PrivilegedAllowed"
          }
      }

      PodSetPrivilegedRule(resource) {
          resource.Object.spec.containers[_].securityContext.privileged == true
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "danger"

          workloadsSetPrivilegedRule(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "PrivilegedAllowed"
          }
      }

      workloadsSetPrivilegedRule(resource) {
          resource.Object.spec.template.spec.containers[_].securityContext.privileged == true
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "danger"

          CronJobSetPrivilegedRule(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "PrivilegedAllowed"
          }
      }

      CronJobSetPrivilegedRule(resource) {
          resource.Object.spec.jobTemplate.spec.template.spec.containers[_].securityContext.privileged == true
      }
  - module: kubeeye_workloads_rego
    name: priorityClassRule
    rule: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "ignore"

          PodPriorityClassNameRule(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoPriorityClassName"
          }
      }

      PodPriorityClassNameRule(resource) {
          not resource.Object.spec.priorityClassName
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "ignore"

          workloadsPriorityClassNameRule(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoPriorityClassName"
          }
      }

      workloadsPriorityClassNameRule(resource) {
          not resource.Object.spec.template.spec.priorityClassName
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "ignore"

          CronJobPriorityClassNameRule(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoPriorityClassName"
          }
      }

      CronJobPriorityClassNameRule(resource) {
          not resource.Object.spec.jobTemplate.spec.template.spec.priorityClassName
      }
  - module: kubeeye_workloads_rego
    name: memoryRequestsRule
    rule: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "danger"

          PodSetMemoryRequests(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoMemoryRequests"
          }
      }

      PodSetMemoryRequests(resource) {
          containers := resource.Object.spec.containers[_]
          not containers.resources.requests.memory
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "danger"

          workloadsSetMemoryRequests(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoMemoryRequests"
          }
      }

      workloadsSetMemoryRequests(resource) {
          containers := resource.Object.spec.template.spec.containers[_]
          not containers.resources.requests.memory
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "danger"

          CronjobSetMemoryRequests(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoMemoryRequests"
          }
      }

      CronjobSetMemoryRequests(resource) {
          containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
          not containers.resources.requests.memory
      }
  - module: kubeeye_workloads_rego
    name: memoryLimitsRule
    rule: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "danger"

          PodSetMemoryLimits(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoMemoryLimits"
          }
      }

      PodSetMemoryLimits(resource) {
          containers := resource.Object.spec.containers[_]
          not containers.resources.limits.memory
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "danger"

          workloadsSetMemoryLimits(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoMemoryLimits"
          }
      }

      workloadsSetMemoryLimits(resource) {
          containers := resource.Object.spec.template.spec.containers[_]
          not containers.resources.limits.memory
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "danger"

          CronjobSetMemoryLimits(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoMemoryLimits"
          }
      }

      CronjobSetMemoryLimits(resource) {
          containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
          not containers.resources.limits.memory
      }
  - module: kubeeye_workloads_rego
    name: livenessProbeRule
    rule: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "warning"

          PodSetlivenessProbe(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoLivenessProbe"
          }
      }

      PodSetlivenessProbe(resource) {
          containers := resource.Object.spec.containers[_]
          not containers.livenessProbe
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "warning"

          workloadsSetlivenessProbe(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoLivenessProbe"
          }
      }

      workloadsSetlivenessProbe(resource) {
          containers := resource.Object.spec.template.spec.containers[_]
          not containers.livenessProbe
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "warning"

          CronjobSetlivenessProbe(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoLivenessProbe"
          }
      }

      CronjobSetlivenessProbe(resource) {
          containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
          not containers.livenessProbe
      }
  - module: kubeeye_workloads_rego
    name: insecureCapabilitiesRule
    rule: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "warning"

          PodSetInsecureCapabilities(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "InsecureCapabilities"
          }
      }

      PodSetInsecureCapabilities(resource) {
          insecureCapabilities := ["CHOWN", "DAC_OVERRIDE", "FSETID", "FOWNER", "MKNOD", "NET_RAW", "SETGID", "SETUID", "SETFCAP", "NET_BIND_SERVICE","SYS_CHROOT","KILL","AUDIT_WRITE"]
          containers := resource.Object.spec.containers[_]
          insecureCapabilities[_] == containers.securityContext.capabilities.add[_]
      } else {
          insecureCapabilities := ["CHOWN", "DAC_OVERRIDE", "FSETID", "FOWNER", "MKNOD", "NET_RAW", "SETGID", "SETUID", "SETFCAP", "NET_BIND_SERVICE","SYS_CHROOT","KILL","AUDIT_WRITE"]
          insecureCapabilities[_] == resource.Object.spec.securityContext.capabilities.add[_]
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "warning"

          WorkloadsSetInsecureCapabilities(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "InsecureCapabilities"
          }
      }

      WorkloadsSetInsecureCapabilities(resource) {
          insecureCapabilities := ["CHOWN", "DAC_OVERRIDE", "FSETID", "FOWNER", "MKNOD", "NET_RAW", "SETGID", "SETUID", "SETFCAP", "NET_BIND_SERVICE","SYS_CHROOT","KILL","AUDIT_WRITE"]
          containers := resource.Object.spec.template.spec.containers[_]
          insecureCapabilities[_] == containers.securityContext.capabilities.add[_]
      } else {
          insecureCapabilities := ["CHOWN", "DAC_OVERRIDE", "FSETID", "FOWNER", "MKNOD", "NET_RAW", "SETGID", "SETUID", "SETFCAP", "NET_BIND_SERVICE","SYS_CHROOT","KILL","AUDIT_WRITE"]
          insecureCapabilities[_] == resource.Object.spec.template.spec.securityContext.capabilities.add[_]
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "warning"

          CronjobSetInsecureCapabilities(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "InsecureCapabilities"
          }
      }

      CronjobSetInsecureCapabilities(resource) {
          insecureCapabilities := ["CHOWN", "DAC_OVERRIDE", "FSETID", "FOWNER", "MKNOD", "NET_RAW", "SETGID", "SETUID", "SETFCAP", "NET_BIND_SERVICE","SYS_CHROOT","KILL","AUDIT_WRITE"]
          containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
          insecureCapabilities[_] == containers.securityContext.capabilities.add[_]
      } else {
          insecureCapabilities := ["CHOWN", "DAC_OVERRIDE", "FSETID", "FOWNER", "MKNOD", "NET_RAW", "SETGID", "SETUID", "SETFCAP", "NET_BIND_SERVICE","SYS_CHROOT","KILL","AUDIT_WRITE"]
          insecureCapabilities[_] == resource.Object.spec.jobTemplate.spec.template.spec.securityContext.capabilities.add[_]
      }
  - module: kubeeye_workloads_rego
    name: imageTagRule
    rule: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "warning"

          PodImageTagRule(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "ImageTagIsLatest"
          }
      }

      PodImageTagRule(resource) {
          regex.match("^.+:latest$", input.Object.spec.containers[_].image)
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "warning"

          workloadsImageTagRule(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "ImageTagIsLatest"
          }
      }

      workloadsImageTagRule(resource) {
          regex.match("^.+:latest$", resource.Object.spec.template.spec.containers[_].image)
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "warning"

          CronJobImageTagRule(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "ImageTagIsLatest"
          }
      }

      CronJobImageTagRule(resource) {
          regex.match("^.+:latest$", resource.Object.spec.jobTemplate.spec.template.spec.containers[_].image)
      }
  - module: kubeeye_workloads_rego
    name: imageTagMissingRule
    rule: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "danger"

          not PodImageTagRule(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "ImageTagMiss"
          }
      }

      PodImageTagRule(resource) {
          regex.match("^.+:.+$", input.Object.spec.containers[_].image)
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "danger"

          not workloadsImageTagRule(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "ImageTagMiss"
          }
      }

      workloadsImageTagRule(resource) {
          regex.match("^.+:.+$", resource.Object.spec.template.spec.containers[_].image)
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "danger"

          not CronJobImageTagRule(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "ImageTagMiss"
          }
      }

      CronJobImageTagRule(resource) {
          regex.match("^.+:.+", resource.Object.spec.jobTemplate.spec.template.spec.containers[_].image)
      }
  - module: kubeeye_workloads_rego
    name: imagePullPolicyRule
    rule: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "warning"

          PodimagePullPolicyRule(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "ImagePullPolicyNotAlways"
          }
      }

      PodimagePullPolicyRule(resource) {
          imagePullPolicy := resource.Object.spec.containers[_].imagePullPolicy
          imagePullPolicy != "Always"
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "warning"

          workloadsimagePullPolicyRule(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "ImagePullPolicyNotAlways"
          }
      }

      workloadsimagePullPolicyRule(resource) {
          imagePullPolicy := resource.Object.spec.template.spec.containers[_].imagePullPolicy
          imagePullPolicy != "Always"
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "warning"

          CronJobimagePullPolicyRule(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "ImagePullPolicyNotAlways"
          }
      }

      CronJobimagePullPolicyRule(resource) {
          imagePullPolicy := resource.Object.spec.jobTemplate.spec.template.spec.containers[_].imagePullPolicy
          imagePullPolicy != "Always"
      }
  - module: kubeeye_workloads_rego
    name: hostPortRule
    rule: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "danger"

          PodSethostPort(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "HostPortAllowed"
          }
      }

      PodSethostPort(resource) {
          resource.Object.spec.containers[_].ports[_].hostPort
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "danger"

          workloadsSethostPort(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "HostPortAllowed"
          }
      }

      workloadsSethostPort(resource) {
          resource.Object.spec.template.spec.containers[_].ports[_].hostPort
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "danger"

          CronJobSethostPort(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "HostPortAllowed"
          }
      }

      CronJobSethostPort(resource) {
          resource.Object.spec.jobTemplate.spec.template.spec.containers[_].ports[_].hostPort
      }
  - module: kubeeye_workloads_rego
    name: hostPIDRule
    rule: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "danger"

          PodSethostPID(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "HostPIDAllowed"
          }
      }

      PodSethostPID(resource) {
          resource.Object.spec.hostPID == true
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "danger"

          workloadsSethostPID(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "HostPIDAllowed"
          }
      }

      workloadsSethostPID(resource) {
          resource.Object.spec.template.spec.hostPID == true
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "danger"

          CronJobSethostPID(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "HostPIDAllowed"
          }
      }

      CronJobSethostPID(resource) {
          resource.Object.spec.jobTemplate.spec.template.spec.hostPID == true
      }
  - module: kubeeye_workloads_rego
    name: hostNetworkRule
    rule: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "danger"

          PodSethostNetwork(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "HostNetworkAllowed"
          }
      }

      PodSethostNetwork(resource) {
          resource.Object.spec.hostNetwork == true
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "danger"

          workloadsSethostNetwork(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "HostNetworkAllowed"
          }
      }

      workloadsSethostNetwork(resource) {
          resource.Object.spec.template.spec.hostNetwork == true
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "danger"

          CronJobSethostNetwork(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "HostNetworkAllowed"
          }
      }

      CronJobSethostNetwork(resource) {
          resource.Object.spec.jobTemplate.spec.template.spec.hostNetwork == true
      }
  - module: kubeeye_workloads_rego
    name: hostIPCRule
    rule: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "danger"

          PodSethostIPC(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "HostIPCAllowed"
          }
      }

      PodSethostIPC(resource) {
          resource.Object.spec.hostIPC == true
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "danger"

          workloadsSethostIPC(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "HostIPCAllowed"
          }
      }

      workloadsSethostIPC(resource) {
          resource.Object.spec.template.spec.hostIPC == true
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "danger"

          CronJobSethostIPC(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "HostIPCAllowed"
          }
      }

      CronJobSethostIPC(resource) {
          resource.Object.spec.jobTemplate.spec.template.spec.hostIPC == true
      }
  - module: kubeeye_workloads_rego
    name: highRiskCapabilitiesRule
    rule: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "danger"

          PodSetHighRiskCapabilities(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "HighRiskCapabilities"
          }
      }

      PodSetHighRiskCapabilities(resource) {
          HighRiskCapabilities := ["NET_ADMIN", "SYS_ADMIN", "ALL"]
          containers := resource.Object.spec.containers[_]
          HighRiskCapabilities[_] == containers.securityContext.capabilities.add[_]
      } else {
          HighRiskCapabilities := ["NET_ADMIN", "SYS_ADMIN", "ALL"]
          HighRiskCapabilities[_] == resource.Object.spec.securityContext.capabilities.add[_]
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "danger"

          WorkloadsSetHighRiskCapabilities(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "HighRiskCapabilities"
          }
      }

      WorkloadsSetHighRiskCapabilities(resource) {
          HighRiskCapabilities := ["NET_ADMIN", "SYS_ADMIN", "ALL"]
          containers := resource.Object.spec.template.spec.containers[_]
          HighRiskCapabilities[_] == containers.securityContext.capabilities.add[_]
      } else {
          HighRiskCapabilities := ["NET_ADMIN", "SYS_ADMIN", "ALL"]
          HighRiskCapabilities[_] == resource.Object.spec.template.spec.securityContext.capabilities.add[_]
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "danger"

          CronjobSetHighRiskCapabilities(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "HighRiskCapabilities"
          }
      }

      CronjobSetHighRiskCapabilities(resource) {
          HighRiskCapabilities := ["NET_ADMIN", "SYS_ADMIN", "ALL"]
          containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
          HighRiskCapabilities[_] == containers.securityContext.capabilities.add[_]
      } else {
          HighRiskCapabilities := ["NET_ADMIN", "SYS_ADMIN", "ALL"]
          HighRiskCapabilities[_] == resource.Object.spec.jobTemplate.spec.template.spec.securityContext.capabilities.add[_]
      }
  - module: kubeeye_workloads_rego
    name: allowPrivilegeEscalationRule
    rule: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "danger"

          PodSetallowPrivilegeEscalation(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "PrivilegeEscalationAllowed"
          }
      }

      PodSetallowPrivilegeEscalation(resource) {
          resource.Object.spec.securityContext.allowPrivilegeEscalation == true
      } else {
          resource.Object.spec.containers[_].securityContext.allowPrivilegeEscalation == true
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "danger"

          DownloadsSetallowPrivilegeEscalation(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "PrivilegeEscalationAllowed"
          }
      }

      DownloadsSetallowPrivilegeEscalation(resource) {
          resource.Object.spec.template.spec.containers[_].securityContext.allowPrivilegeEscalation == true
      } else {
          resource.Object.spec.template.spec.securityContext.allowPrivilegeEscalation == true
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "danger"

          CronjobSetallowPrivilegeEscalation(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "PrivilegeEscalationAllowed"
          }
      }

      CronjobSetallowPrivilegeEscalation(resource) {
          resource.Object.spec.jobTemplate.spec.template.spec.containers[_].securityContext.allowPrivilegeEscalation == true
      } else {
          resource.Object.spec.jobTemplate.spec.template.spec.securityContext.allowPrivilegeEscalation == true
      }
  - module: kubeeye_workloads_rego
    name: CPURequestsRule
    rule: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "danger"

          PodSetCPURequests(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoCPURequests"
          }
      }

      PodSetCPURequests(resource) {
              containers := resource.Object.spec.containers[_]
              not containers.resources.requests.cpu
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "danger"

          workloadsSetCPURequests(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoCPURequests"
          }
      }

      workloadsSetCPURequests(resource) {
          containers := resource.Object.spec.template.spec.containers[_]
          not containers.resources.requests.cpu
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "danger"

          CronjobSetCPURequests(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoCPURequests"
          }
      }

      CronjobSetCPURequests(resource) {
          containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
          not containers.resources.requests.cpu
      }
  - module: kubeeye_workloads_rego
    name: CPULimitsRule
    rule: |-
      package kubeeye_workloads_rego

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "Pod"
          level := "danger"

          PodSetCPULimits(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoCPULimits"
          }
      }

      PodSetCPULimits(resource) {
          containers := resource.Object.spec.containers[_]
          not containers.resources.limits.cpu
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          workloadsType := {"Deployment","ReplicaSet","DaemonSet","StatefulSet","Job"}
          workloadsType[type]
          level := "danger"

          workloadsSetCPULimits(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoCPULimits"
          }
      }

      workloadsSetCPULimits(resource) {
          containers := resource.Object.spec.template.spec.containers[_]
          not containers.resources.limits.cpu
      }

      deny[msg] {
          resource := input
          type := resource.Object.kind
          resourcename := resource.Object.metadata.name
          resourcenamespace := resource.Object.metadata.namespace
          type == "CronJob"
          level := "danger"

          CronjobSetCPULimits(resource)

          msg := {
              "Name": sprintf("%v", [resourcename]),
              "Namespace": sprintf("%v", [resourcenamespace]),
              "Type": sprintf("%v", [type]),
              "Level": sprintf("%v", [level]),
              "Message": "NoCPULimits"
          }
      }

      CronjobSetCPULimits(resource) {
          containers := resource.Object.spec.jobTemplate.spec.template.spec.containers[_]
          not containers.resources.limits.cpu
      }